# coding=utf-8
from _eventmanager import *

"""
Библиотека eventmanager была создана для упрощённого использования потоков в python.

Многопоточность нужна для обеспечения параллельной работы сразу нескольких процессов. Как пример в один момент времени 
может происходить проверка нажатия на один из сенсоров, движение и разговор. Все это на одном потоке сделать крайне
трудно и не красиво, поэтому фоновые задачи были вынесены на дополнительные.

Отличным примером будет файл walking_with_nao, по сути обработчик событий был создан для реализации этого проекта
"""

"""
#############################################------------------------------#############################################
##########################################------- ОСНОВНОЙ  ФУНКЦИОНАЛ -------##########################################
#############################################------------------------------#############################################
"""

"""
Создание экземпляра объекта Event

Event(func, args, predicate, single_use, threadable)
func - ваша функция
args - аргументы передаваемые в функцию
predicate - триггер срабатывания (условие)
single_use - вызвать всего один раз? True False
threadable - вызвать на отдельном потоке? True False
"""

# obj = Event(my_function, ["hi, Mark"], x > 5, single_use=True, threadable=False)

"""
В итоге был создан экземпляр ивента, который должен срабатывать сразу, всего один раз и не на потоке.

Однако его теперь нужно как-то обработать. Для этого нужно создать обработчик событий и добавить наше событие в очередь
выполнения
"""

event_handler = Eventloop()


def my_function(text):
    print(text)


x = 1
obj = Event(my_function, ["hi, Mark"], lambda: x >= 5, single_use=True, threadable=False)

event_handler.add_event(obj)

"""
Отлично, был создан обработчик. Теперь нужно его запустить и проверить все ли работает
"""

event_handler.start()
for i in range(10):
    x = i
    print(x)
    time.sleep(1)

"""
Для корректного завершения работы обработчика нужно добавить команду остановки и ожидания остановки
"""

event_handler.stop()
event_handler.join()

print("Все прошло успешно")

"""
#############################################------------------------------#############################################
#######################################------- Дополнительный  ФУНКЦИОНАЛ -------#######################################
#############################################------------------------------#############################################
"""

"""
Некоторая группа каким-либо связанных событий может иметь общую задержку. Для этого были созданны группы ивентов

my_group = EventGroup(predicate=True, cooldown=100)

predicate - условие при котором будет обрабатываться группа событий
cooldown - задержка между обработкой событий этой группы
"""

my_group = EventGroup(predicate=True, cooldown=100)
my_group.add_event(obj)

"""
Также есть два готовых предиката
------------------------------------------------------------------------------------------------------------------------
binary_predicate(state, zero_to_one, one_to_zero)

state - проверяемая переменная (0 или 1)
zero_to_one - предикат возвращает True при изменении состояния с 0 да 1
one_to_zero - предикат возвращает True при изменении состояния с 1 да 0
------------------------------------------------------------------------------------------------------------------------
changed_value_predicate(value_supplier)

value_supplier - проверяемое значение. В случае если больше 0.5, возвращает True
"""